# Orchagent Error Handling Improvements #
## High Level Design Document
### Rev 0.1

# Table of Contents
  * [Revision](#revision)
  * [Scope](#scope)
  * [Definitions/Abbreviation](#definitionsabbreviations)
  * [Overview](#overview)
  * [Requirements](#requirements)
  * [Motivation](#motivation)
  * [Design](#high-level-design)
    * [Orchagent changes](#orchagent-changes)
      * [Avoid self-induced orchagent aborts in response to SAI errors](#1-avoid-self-induced-orchagent-aborts-in-response-to-sai-errors)
      * [Detect missed notifications from APP_DB to orchagent](#2-detect-missed-notifications-from-app_db-to-orchagent)
      * [Detect out-of-sync entries between APP_DB and ASIC_DB](#3-detect-out-of-sync-entries-between-app_db-and-asic_db)
  * [Warm Boot Support](#warmboot-and-fastboot-design-impact)
  * [Unit Tests](#unit-test-cases)
  * [System Tests](#system-test-cases)
  * [Unsupported features](#9-Unsupported-features)

### Revision

| Rev |     Date    |       Author       | Change Description          |
|:---:|:-----------:|:-------------------------|:----------------------|
| 0.1 |  03/6/2024  |   Prabhat Aravind  | Initial version             |

### Scope

This document describe the details of error handling changes in SONiC Orchestration Agent to improve orchagent resiliency and to gracefully handle ASIC/SAI programming failures without causing dataplane impact.

### Definitions/Abbreviations

This section covers the abbreviation if any, used in this high-level design document and its definitions.

|                          |                                          |
|--------------------------|------------------------------------------|
| Orchagent                | Orchestration Agent                      |
| SAI                      | Switch Abstraction Interface             |
| ASIC                     | Application Specific Integrated Circuit  |
| APP_DB                   | Application Database                     |
| ASIC_DB                  | ASIC Database                     |

### Overview

Orchagent is one of the most critical components in SONiC that is responsible for translating the data generated by applications into SAI objects that can be pushed down to the hardware via the southbound interface. As such, the reliability of this component is of great importance to the stability and availability of system running SONiC. Currently, most of the ASIC/SAI programming failures in SONiC result in a crash/restart of orchagent which can potentially cause dataplane impact and degraded customer experience. This is a legacy/day-1 behavior. The intent of this document is to come up with a solution where such errors are handled gracefully by orchagent without a crash or restart. Also being addressed as part of this are some improvements in detecting and mitigating some of the common orchagent issues which can potentially cause sever dataplane impact. These improvements are primarily in the flows #1, #2 and #6 referenced in the flow diagram below:

![orchagent flow](images/orchagent_flow.png)

P.S: The diagram above is intended as a high-level overview of the components that are at play for redis based pub-sub architecture used in SONiC.

#### Goals

- Handle all ASIC/SAI programming errors gracefully without causing orchagent to crash or restart
- Detect missed notifications from APP_DB to orchagent in SONiC systems that use redis-based communication channels
- Detect out-of-sync entries between APP_DB and ASIC_DB

#### Non-Goals

- Propagation of errors from orchagent to upper layers via mechanisms like ERROR_DB
- Detection of missed or pending notifications in SONiC systems that use ZMQ-based communication channels


#### Motivation

Orchagent is of great significance in SONiC design primarily because of it being an intermediary between applications and the ASIC. An issue in orchagent can potentially cause missed notifications to the ASIC-DB potentially causing catastrophic imapct down the line. In addition, there could be situations where certain operations may not be synced to ASIC-DB either due to missing dependencies, system resource unavailibility or other gating sanity check failures. It is imperative that in addition to taking appropriate actions such as aborting the operation or retrying the operation, a meaningful message is logged into syslog so that automation can monitor and remediate such situations in a timely manner. Lastly but most importantly, since orchagent crash brings down dataplane, it does not make sense to let it crash for all failed operations, especially for trivial cases like an ADD operation for an object that already exists or a DEL operation for an object that has already been deleted. This was a day-1 design decision and probably one that made sense in the early days of adoption for SONiC. It was a simple and efficient way to recover a potentially degraded dataplane and start everything afresh but as orchagent and SONiC as a whole has evolved to such a scale that such dataplane disruptions with potentially huge customer impact can no longer be justified. It is therefore of utmost importance to improve error detection and handling in orchagent inorder to make SONiC more resilient and reliable.

### Architecture Design

No change in SONiC architecture is intended with this orchagent error handling behavioral change.

### High-Level Design

This HLD discusses three potential ways in which orchagent behavior today can be improved:

1. Avoid self-induced orchagent aborts in response to SAI errors

    The most significant change in this proposal is to do away with self-induced orchagent crashes when a SAI API call fails (i.e, when the call returns anything other than SAI_STATUS_SUCCESS) as is the case for a large proportion of SAI errors handled today by different orchs that constitute orchagent.

    All existing SAI error statuses are planned to be gracefully handled by orchagent without causing it to exit. The orchagent error handling behavioral changes introduced here will be the standard behavior going forward on all SONiC platforms with no option to retain the existing behavior. All changes will be limited to orchagent inside the swss container and in standalone scripts that are run periodically using monit infrastructure in SONiC.

2. Detect missed notifications from APP_DB to orchagent

    There have been instances where orchagent missed certain APP_DB table entry notifications in a race condition with a rather innocuous logrotate event. This caused those notifications to linger in the redis channel between APP_DB and orchagent without being consumed atll by Orchagent. It is quite obvious that this can be quite detrimental for entries which undergo lots of updates under normal circumstances. For eg: a link down event on a portchannel member may not be synced to ASIC-DB due to this resulting in traffic blackhole. While the root cause of that was a bug in code which was fixed later, it was understood that such conditions are painfully difficult to debug and mitigate without proper failsafe mechanisms. One of the mechanisms that we propose to alleviate this problem is to have a script that monitors APP_DB for unconsumed entries periodically using monit framework and nudge the notifications down to orchagent using sonic-db-cli PUBLISH command so they get consumed right away.

3. Detect out-of-sync entries between APP_DB and ASIC_DB

    This is a situation that is similar to the one discussed above, but slightly different in the sense that these notifications are not missed by Orchagent. These notifications have been processed by orchagent but have not been synced to ASIC-DB due to either failed dependency checks or other conflicts resulting in retries. In this case the entries are part of m_toSync data structure until they are successfully added to ASIC_DB. A good example for such a situation is where a route addition fails when the nexthop neighbor is not resolved. This will trigger a set of retries in orchagent with the expectation that it will eventually succeed, however in many cases the situation may not resolve itself and will need an intervention. Such situations are easily overlooked when trying to narrow down the root cause for a traffic loss scenario in a complex network deployment. While route_check.py script does help to identify such routes which are out of sync between APP_DB and ASIC_DB, a more generic object-agnostic way of determining entries that are out of sync between APP_DB and ASIC_DB at any given time is needed. Our proposal is to either leverage the script used in #1 to also determine such pending entries in a periodic manner using monit or otherwise extend the main loop of orchagent to check for pending entries after each iteration, i.e after executing doTask() methods for all the orchs in m_orchList once.

## Orchagent changes

### 1. Avoid self-induced orchagent aborts in response to SAI errors

![orch error handling](images/orch_error_handling.png)

When orchagent receives an error notification from syncd for a SAI API call that failed,
one of three actions will be performed in one of the handleSai<Op>Status() functions in orchagent, depending on whether the operation was a create, set, remove or get:

 a. If the error is something that can resolve itself with subsequent retries like for eg: SAI_STATUS_OBJECT_IN_USE or SAI_STATUS_TABLE_FULL, handleSai<Op>Status() will return task_need_retry. Such errors are highlighted in yellow in the table below.

 b. If the error is something that is unlikely to be resolved with a subsequent attempt like for eg: SAI_STATUS_NOT_SUPPORTED, orchagent will call handleSaiFailure() with abort_on_failure set to False by default so orchagent does not exit and handleSai<Op>Status() will return task_failed. This will also log an ERROR syslog message.
 Such errors are highlighted in red in the table below.

 c. If the error is rather harmless like SAI_STATUS_ITEM_ALREADY_EXISTS or SAI_STATUS_ITEM_NOT_FOUND, orchagent will log an INFO syslog message and return task_success such that no retries will be attempted. Such errors are highlighted in green in the table below.

![sai status handling](images/sai_status_handling.png)

It is to be noted that some combinations in the table above are not valid scenarios like for example: SAI_STATUS_INSUFFICIENT_RESOURCES when removing an object or SAI_STATUS_ITEM_NOT_FOUND when creating an object. They are however mentioned for completeness.

### 2. Detect missed notifications from APP_DB to orchagent

A new python script will be introduced whose job is to verify that there are no notifications from APP_DB that are yet to be seen or consumed by orchagent over a specified period of time. The initial plan is to introduce this monitoring and mitgation only for certain dynamic APP_DB tables that undergo a lot of churn like LAG_MEMBER_TABLE, LAG_TABLE, NEIGH_TABLE, ROUTE_TABLE, INTF_TABLE and MUX_CABLE_TABLE.

The script workflow will be as follows:

* Read aforementioned APP_DB tables once for unconsumed entries. These entries show up in APP_DB with an "_" prefix.
* Wait 30 seconds.
* Read APP_DB tables again for unconsumed entries
* If there are overlapping entries between both reads,
    * Return a non-zero error code
  Else
    * Return zero

This script will be called periodically every 15 minutes using monit infrastructure and alert will be generated by monit if the script returns a non-zero status for 3 cycles. This helps in faster detection and mitigation of such issues. \
It is to be noted that this is not applicable for ZMQ based producers/consumers.

### 3. Detect out-of-sync entries between APP_DB and ASIC_DB

A new binary query_orchagent will be introduced in swss container which will talk to orchagent using redis notification channels ORCHAGENTQUERY and ORCHAGENTQUERYREPLY similar to the RESTARTCHECK and RESTARTREPLY channels used for warm restart readiness check.
query_orchagent will act as the notification producer on ORCHAGENTQUERY channel and be notification consumer on the ORCHAGENTQUERYREPLY channel while switchorch in orchagent will act as the notification producer on ORCHAGENTQUERYREPLY channel and act as the notification consumer on ORCHAGENTQUERY channel. It is to be noted that while query_orchagent is used in this particular case for determing out-of-sync entries between APP_DB and ASIC_DB, the design is generic enough to be used as a mechanism to retrieve any desired data from orchagent using appropriate command options to query_orchagent. For the specific case of getting pending entries from orchagent, query_orchagent will be run with an option "-p".

Call flow:

![pending entries check](images/pending_entries_check.png)

1. When query_orchagent binary is run with the option "-p", it will create a NotificationProducer for APP_DB "ORCHAGENTQUERY" channel and a NotificationConsumer for APP_DB "ORCHAGENTQUERYREPLY" channel. It will then send a notification on the "ORCHAGENTQUERY" channel with opcode set to "orchagent" (as is done today for "RESTARTCHECK" notifications) and FieldValueTuple containing the following:

    - "PendingCheck": "true"

2. When doTask() for switchorch gets called, this notification is processed by switchorch which sets a member variable m_getPendingEntries to True.

3. At the end of Orchagent's main while loop after doTask() for all orchs have been called, orchagent will call getPendingEntries() function to retrieve the entries that have yet to be programmed to ASIC_DB only if switchorch's m_getPendingEntries is set to True. This ensures that every orchagent loop does not incur an additional cost of processing pending entries. Pending entries can be obtained from the m_toSync maps associated with each orch's consumer.

4. getPendingEntries() will call the existing getTaskToSync() function which returns all the pending entries as a vector of strings.

5. getPendingEntries() will then call gsWitchOrch->sendPendingEntriesResponse() which will  send the pending entries to query_orchagent process using ORCHAGENTQUERYREPLY notification channel and subsequently set m_getPendingEntries to False. Subsequent orchagent main loop iterations will not retrive pending entries until query_orchagent sends another notification after a specified period of time.

6. query_orchagent process will then listen to notifications on ORCHAGENTQUERYREPLY channel and retrieve the pending entries in orchagent.

7. query_orchagent can then compare the most recently obtained set of pending entries to the previously stashed copy of pending entries and determine if any of the entries are stuck in processing beyond a specific timeframe of 5 minutes. If so, an ERROR message can be logged into syslog. This will help debug and mitigate such issues faster.
 
### SAI API

No new SAI APIs are introduced as part of this functionaility.

### Configuration and management
There are no configuration and management changes introduced as part of this functionality.

#### CLI/YANG model Enhancements

There is no CLI change associated with this functionality.

#### Config DB Enhancements

There is no config DB change needed for this functionality.

### Warmboot and Fastboot Design Impact

This error handling improvement does not have any requirements or dependencies w.r.t warmboot or fastboot.
Warm reboot does not currently go through when there are pending orchagent entries that have yet to be programmed to ASIC_DB and that behavior will stay as-is.

### Memory Consumption

No significant additional memory overhead is anticipated in implementing this functionality.

### Restrictions/Limitations

### Testing Requirements/Design

### Unit Test cases

The unit test plan for orchagent error handling is documented below:

| S.No | Test description                                             |
| ---- | ------------------------------------------------------------ |
| 1  | Gtest to verify that orchagent does not crash when SAI_STATUS_NOT_SUPPORTED is returned |
| 2  | Gtest to verify that orchagent does not crash when SAI_STATUS_NO_MEMORY is returned |
| 3  | Gtest to verify that orchagent does not crash when SAI_STATUS_INSUFFICIENT_RESOURCES is returned |
| 4  | Gtest to verify that orchagent does not crash when SAI_STATUS_INVALID_PARAMETER is returned |
| 5  | Gtest to verify that orchagent does not crash when SAI_STATUS_ITEM_ALREADY_EXISTS is returned |
| 6  | Gtest to verify that orchagent does not crash when SAI_STATUS_ITEM_NOT_FOUND is returned |
| 7  | Gtest to verify that orchagent does not crash when SAI_STATUS_TABLE_FULL is returned |
| 8  | Gtest to verify that orchagent does not crash when SAI_STATUS_NOT_IMPLEMENTED is returned |
| 9  | Gtest to verify that orchagent does not crash when SAI_STATUS_OBJECT_IN_USE is returned |
| 10 | Gtest to verify that orchagent does not crash when SAI_STATUS_NOT_EXECUTED is returned |

### System Test cases

TBD

### Open/Action items

Leverage ERROR_DB that is already available to escalate the errors from Orchagent to upper layers/applications.

