# SAI Validation and PySAI HLD


- [SAI Validation and PySAI HLD](#sai-validation-and-pysai-hld)
    - [1. Revision](#1-revision)
    - [2. Scope](#2-scope)
    - [3. Definitions/Abbreviations](#3-definitionsabbreviations)
    - [4. Overview](#4-overview)
    - [5. Requirements](#5-requirements)
    - [6. High-Level Design](#6-high-level-design)
      - [PySAI Workflow](#pysai-workflow)
      - [SAI Validation HLD](#sai-validation-hld)
    - [7. Open/Action items](#7-openaction-items)
### 1. Revision  

| Revision | Date        | Author           | Change Description |
| -------- | ----------- | ---------------- | ------------------ |
| 1.0      | March 8 2025 | Boyang Zhou, Yiming Yang, Zheyuan wu | Initial proposal   |

### 2. Scope  
This document presents a new Python framework designed for SAI performance verification and testing on a single Device Under Test (DUT), named SAI Validation, along with its supporting infrastructure, PySAI.

### 3. Definitions/Abbreviations 


| Definitions/Abbreviation | Description |
| ------------------------ | ----------- |
| SAI | Switch Abstraction Interface |
| RPC| Remote Procedure calls |
| SONiC | Software for Open Networking in the Cloud |
| DUT | Device Under Test |
| L2 | Layer 2 |
| L3 | Layer 3 |

### 4. Overview 

This document provides an overview of the work process and advantages of SAI Validation. SAI Validation serves as a robust tool for assessing the functionality and performance of SAI APIs, which are implemented in Python with the help of PySAI. PySAI, a submodule of SAI Validation, bridges the gap between SAI C APIs and Python APIs. PySAI is set to be open-sourced alongside SAI Validation since it is the fundamental part of SAI Validation. The development of SAI Validation is motivated by its ability to address two critical gaps in testing SAI APIs:

- Single-Device Testing: SAI Validation allows for testing on a single Device Under Test (DUT) without the need for a complex network topology and RPC servers. This simplification is crucial as it enables users to conduct thorough testing without requiring multiple interconnected devices, thus reducing setup complexity and resource requirements.

- All-in-One Capability: This tool supports a variety of functionalities essential for both diagnosing issues and furthering API development. Features like sairedis.rec recording and replay are integrated into the framework, providing a comprehensive environment for handling a wide range of testing and development scenarios in one package.


Compared with existing SAI testing tools (PTF), SAI Validation provides following advantages:

- **4.1 Single-Device Testing and Deployment**

  SAI Validation runs in a standalone Docker container on a single Device Under Test (DUT), independent of SONiC and external dependencies. The Docker image can be deployed directly on the host CPU of a Linux-based switch, enabling local execution of the SAI validation workflow.

  Packet transmission is performed using port loopback mode, removing the need for external connectivity or change in topology. Unlike the PTF-based approach, this setup does not require fanout switches or RPC servers, which reduces testbed complexity.

  <p align="center">
  <img src="overview.png" alt="Figure 1. Deployment of SAI Validation under Single DUT" width="200">
  </p>
  <p align="center"><em>Figure 1. Deployment of SAI Validation under Single DUT</em></p>

- **4.2 Simplified and Unified Syntax**
  
  SAI Validation leverages Pythonic APIs generated by PySAI, reducing the amount of code required for test case development. Table 1 summarizes the basic mapping rules between native SAI and PySAI.
  
  An example is provide to compare the create, remove, get, and get operations using native SAI APIs, PTF APIs, and PySAI APIs. The comparison shows that both PTF and PySAI APIs can reduce more than 50% lines of code compared with native SAI APIs. However, unlike PTF APIs, PySAI APIs present a more cohesive approach to making API calls. In PySAI, the methods `xxx.create` and `xxx.remove` are used to invoke create and remove operations for all SAI objects/entries. The operations `val = xxx.attr` and `xxx.attr = val` facilitate get and set operations respectively. Here, `xxx` represents the PySAI class corresponding to the SAI objects/entries, as listed in the first column of Table 1. Additionally, PySAI ensures a direct one-to-one mapping of SAI attributes in creation operations.


  <p align="center"><strong>Table 1: Mapping Rules Between Native SAI and PySAI</strong></p>

    | Native SAI  | PySAI | Explaination |
    |---------------------|---------------------|----------------------|
    | SAI_OBJECT_TYPE_XXX<sup>1</sup>_..._XXX<sup>n</sup> | Xxx<sup>1</sup>...Xxx<sup>n</sup>     | Mapping rules between SAI objects/entries in Native SAI and their corresponding classes in PySAI (e.g., `SAI_OBJECT_TYPE_FDB_ENTRY` in Native SAI corresponds to class `FdbEntry` in PySAI).|
    | attr.id = SAI_xxx<sup>1</sup>_..._xxx<sup>n</sup>; attr.value.s32 = val;   |   SAI_xxx<sup>1</sup>_..._xxx<sup>n</sup>\_(val)   |Set SAI attribute SAI_xxx<sup>1</sup>_..._xxx<sup>n</sup> value to val when creating a SAI object/entry (e.g., `SAI_BRIDGE_ATTR_TYPE_(SAI_BRIDGE_PORT_TYPE_PORT)` indicates setting `SAI_BRIDGE_ATTR_TYPE` attribute to `SAI_BRIDGE_PORT_TYPE_PORT`).   |
    | SAI_*Type*\_ATTR_XXX<sup>1</sup>_..._XXX<sup>n</sup>|   attr_xxx<sup>1</sup>_..._xxx<sup>n</sup>   |Conversion of attributes for getters and setters in PySAI objects/entries, as illustrated in the example above. (e.g., `SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE` can be accessed or modified using `bp.attr_fdb_learning_mode`).|
    | SAI_*Type*\_STAT_XXX<sup>1</sup>_..._XXX<sup>n</sup>|   stats_xxx<sup>1</sup>_..._xxx<sup>n</sup>   |Conversion of stats in PySAI objects/entries. (e.g., `SAI_VLAN_STAT_IN_OCTETS` can be accessed using `vlan.stat_in_octets`, where `vlan` is a instance of class `Vlan` in PySAI).|
    |||

    **4.2.1 Native SAI API for Creating and Removing a Bridge Port in C**

    ```c
    #include <vector>
    #include "sai.h"

    sai_attribute_t attr;
    vector<sai_attribute_t> attrs;

    // Set the type of the bridge port
    attr.id = SAI_BRIDGE_PORT_ATTR_TYPE;
    attr.value.s32 = SAI_BRIDGE_PORT_TYPE_PORT;
    attrs.push_back(attr);

    // Set the port ID
    attr.id = SAI_BRIDGE_PORT_ATTR_PORT_ID;
    attr.value.oid = port.m_port_id;
    attrs.push_back(attr);

    // Create a bridge port with admin status set to UP
    attr.id = SAI_BRIDGE_PORT_ATTR_ADMIN_STATE;
    attr.value.booldata = true;
    attrs.push_back(attr);

    // Set hardware FDB learning mode to HW (hardware learning)
    attr.id = SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE;
    attr.value.s32 = SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW;
    attrs.push_back(attr);

    // Attempt to create the bridge port
    sai_status_t status = sai_bridge_api->create_bridge_port(&port.m_bridge_port_id, gSwitchId, (uint32_t)attrs.size(), attrs.data());

    sai_status_t status = sai_bridge_api->remove_bridge_port(&port.m_bridge_port_id);

    ```

    **4.2.2 PTF API for Creating and Removing a Bridge Port in Python**
    ```python
    bp = sai_thrift_create_bridge_port(
        client,
        bridge_id=self.default_1q_bridge,
        port_id=self.port,
        type=SAI_BRIDGE_PORT_TYPE_PORT,
        admin_state=True,
        fdb_learning_mode=SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW)

    sai_thrift_remove_bridge_port(client, bp)
    ```

    **4.2.3 PySAI API for Creating and Removing a Bridge Port in Python**

    ```python
    bpid = BridgePort.create(
        switch.object_id,
        [SAI_BRIDGE_ATTR_TYPE_(SAI_BRIDGE_PORT_TYPE_PORT),
        SAI_BRIDGE_PORT_ATTR_PORT_ID_(poid),
        SAI_BRIDGE_PORT_ATTR_ADMIN_STATE_(True),
        SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE_(
            SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW)])

    BridgePort.remove(bpid)

    ```
    **4.2.4 Native SAI API Getting and Setting an Attribute of a Bridge Port in C**

    ```c
    #include <vector>
    #include "sai.h"

    sai_attribute_t attr;
    vector<sai_attribute_t> attrs;

    attr.id = SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE;
    attrs.push_back(attr);

    // Attempt to get the attribute of the bridge port
    sai_status_t status = sai_bridge_api->get_bridge_port_attribute(&port.m_bridge_port_id, (uint32_t)attrs.size(), attrs.data());

    attrs.clear();
    
    attr.id = SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE;
    attr.value.s32 = SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW
    attrs.push_back(attr);

    // Attempt to set the attribute of the bridge port
    sai_status_t status = sai_bridge_api->set_bridge_port_attribute(&port.m_bridge_port_id, attrs.data());
    ```

    **4.2.5 PTF API for Getting and Setting the Attribute of a Bridge Port in Python**
    ```python

    // Get the attribute
    attr = sai_thrift_get_bridge_port_attribute(
        client, bp, bridge_id=True)

    // Set the attribute

    status = sai_thrift_set_bridge_port_attribute(
        client,
        bp,
        fdb_learning_mode=SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW)

    ```

    **4.2.6 PySAI API for Getting and Setting the Attribute of a Bridge Port in Python**
    ```python
    // Initialize the BridgePort using the object id
    bp = BridgePort(bpid)

    // Get the attribute
    attr = bp.attr_fdb_learning_mode

    // Set the attribute
    bp.attr_fdb_learning_mode = SAI_BRIDGE_PORT_FDB_LEARNING_MODE_HW

    ```



- **4.3 Life Cycle Automanagement**
    
  While PySAI facilitates the creation and management of SAI objects through Python APIs, the underlying implementation still operates in C. In contrast, SAI Validation introduces an automated memory management system that handles the allocation and deallocation of C data structures. Moreover, SAI Validation extends this automation to the lifecycle management of SAI objects, leveraging Pythonâ€™s garbage collection capabilities. This automation obviates the need for explicit removal of each SAI object created during testing or manual oversight of memory allocation in C data structures, streamlining the entire process.

- **4.4 Dependency Management**
  
  SAI objects and entries often involve dependencies during their creation. For instance, a route entry is dependent on the next hop, which in turn relies on the neighbor entry. SAI Validation manages this chain of dependencies automatically. When integrated with Python's garbage collection for life cycle automanagement, this system handles the removal of SAI objects and entries. It ensures that deletion occurs in a sequence that respects the established dependency chain, thereby safeguarding against errors that may arise from improper order of removal.

- **4.5 Simplified Configuration**
  
  Supporting a new ASIC platform simply requires the addition of vendor-specific board and ASIC configuration files, with no modification to the core SAI Validation frameworkã€‚

- **4.6 Recording Functionality**
  
  PySAI supports the creation of sairedis.rec files during testing, which capture all SAI operations issued throughout a test run. These files serve as an operational trace and can be used for debugging, behavioral verification, and regression analysis. 
  
- **4.7 sairedis.rec Replay Function**
  
  This feature enhances the ability to replay all SAI operations by utilizing one or more sairedis.rec files. Unlike the SAI player function in SONiC, which depends on the syncd docker, the sairedis.rec replay function in SAI Validation operates independently. Additionally, while the SAI player is limited to replaying a single sairedis.rec file, this function supports sequential replay of multiple files. It also features an interactive mode that allows line-by-line replay of SAI operations, stopping at the triggering runtime error to provide instant feedback and facilitate efficient issue diagnosis.

- **4.8 sairedis.rec Extraction Feature**
  
  This feature is designed to identify the dependencies of user-specified lines in sairedis.rec. Cooperating with the sairedis.rec replay function, this feature removes the executing of unnecessary SAI operations during the replay, enhancing the efficiency of testing, debugging, and development.

  For example, consider a sairedis.rec file that performs a large number of SAI operations. If an issue is observed after the final SAI operation, this tool can trace back and extract only the operations that are relevant to that specific line. This enables focused, minimal replay of just the dependent operations, making it much easier to isolate and analyze the problem.

- **4.9 ASIC DB Snapshot Player**
  
  While sai-validation operates independently of SONiC, it supports the optional use of artifacts generated by SONiC-based systems, such as the ASIC_DB.json file, to reconstruct a specific SAI state. This feature enables the restoration of the switchâ€™s SAI environment based on a previously captured ASIC DB snapshot, without requiring replay of the full initialization sequence.

  This mechanism can be applied in scenarios such as reproducing SAI operation failures observed in deployed systems, or initializing the environment to a known state for controlled development and validation. Compared to sairedis.rec-based replay, this method reduces the number of required operations and simplifies environment setup.

- **4.10 Cutomized SAI Support**
  
  SAI Validation and PySAI offer robust support for customized SAI APIs by simply integrating SAI header files that include these customized APIs.

- **4.11 Flexible Notifcation Set**
  
  SAI Validation offers the flexibility to modify the notification functions, such as `sai_fdb_event_notification_fn`, within SAI. These notification callbacks are invoked by the SAI implementation to report asynchronous eventsâ€”such as FDB updates, port state changes, or neighbor removalsâ€”back to the application.
  
- **4.12 Interactive Mode**
  
  Supports interactive, line-by-line debugging and execution with IPython, enhancing the user experience.


### 5. High-Level Design 

In this section, the deployment of SAI Validation and High-Level Design (HLD) of SAI Validation and PySAI are introduced. Figure 2 provides a high-level overview of the deployment. The deployment process is straightforward. Simply load the SAI Validation Docker onto the host CPU operating a Linux OSâ€”there's no need for SONiC OS. This allows users to conduct tests even before SONiC compatibility is established. Having outlined the straightforward deployment process, the focus shifts to the internal architecture and functionality of the SAI Validation and PySAI modules. Figure 2 delineates the workflow of PySAI. PySAI is responsible for generating all Python APIs related to SAI used in the validation process. Many of the benefits highlighted in Section 4 directly from the functionalities provided by PySAI.



#### 5.1 PySAI Workflow

PySAI employs a combination SWIG and Jinja2 to transform the native C API into accessible Python APIs. It incorporates several predefined components, including interface files (.i files) and templates (.j2) to wrap native C APIs to unified and Pytonic Python APIs. PySAI modifies the parse.pl file in the OCP-SAI repository to generate the `saiswig.i` file, instructing SWIG on which APIs need to be wrapped, during the compilation of SAI. SWIG will generate a `saiswig.py` file, which includes the wrapped Python APIs translated from the native SAI API. Additionally, it produces a `_saiswig.so` file that contains the compiled C code, which has been wrapped by SWIG for utilization in Python.

Additionally, generateDS is employed to automatically create an XML parser from XML Schema Definitions (XSD files) generated by Doxygen. This parser works in conjunction with predefined templates to efficiently generate Python APIs using Jinja2. This integrated approach ensures a seamless translation of complex API structures into user-friendly Python modules. The output from Jinja2 consists of a series of Python files, named `sai_xxx.py`, corresponding to the `saixxx.h` header files in the SAI library. Each `sai_xxx.py` file contains classes for SAI objects and entries, all of which inherit from a base class called `SaiObject`. This base class furnishes the essential implementations of the create, remove, set, and get SAI APIs by calling corresponding APIs in `saiswig.py`, providing a consistent and comprehensive interface for interacting with SAI operations. 

Benefits from the centralized implementation of CRUD SAI APIs the in `SaiObject` class, the functionality for recording sairedis.rec is also efficiently integrated within `SaiObject`. Meanwhile, PySAI also enhances its capabilities by offering a sairedis.rec replay function, which utilizes the wrapped APIs provided in the `sai_xxx.py` files. Additionally, it includes a sairedis.rec extract function and a ASIC DB snapshot player module. Together, these components form the comprehensive suite of tools in the PySAI framework.

<table>
  <tr>
    <td><img src="PySAI_workflow_modified.png" width="600" alt="PySAI Working Process"></td>
    <td><img src="SAI_Validation.png" width="600" alt="SAI Validation HLD"></td>
  </tr>
  <tr>
    <td>Figure 2: PySAI Working Process</td>
    <td>Figure 3: SAI Validation HLD</td>
  </tr>
</table>

#### 5.2 SAI Validation HLD

Figure 3 illustrates the High-Level Design (HLD) of sai-validation, which consists of three main directories: platform, cases, and utils. The platform folder serves as the entry point for platform-specific initialization and switch creation within the SAI framework.

At the core of this structure is `Base platform class`, a base class that implements common functionality shared across all supported ASIC platforms. To accommodate platform-specific differences, sai-validation provides `ASIC Specific platform class`, which inherit from `Base platform class` and override only the required methodsâ€”typically for setting up the SAI profile and initialization options. This inheritance model minimizes code duplication and simplifies the process of adding support for new ASIC platforms.

There is a dedicated `utils` folder that contains all the essential infrastructure code necessary in SAI Validation. The three key components contained within this folder include topology build, station build, and life cycle and dependency management. 
1. The topology build component can construct various topologies with different numbers of ports on the same switch and supports the use of port loopback mode. With loopback mode, packets are returned to the same device, allowing the device itself to do the L2 forwarding or L3 routing, as illustrated in Figure 1. This topology functionality facilitates packet forwarding and routing within the same switch, which is crucial for deploying a single DUT setup.

2. The station build component is responsible for constructing and managing station objects in the SAI environment. It facilitates the creation and efficient management of these station objects, which serve as sources and destinations for packet flows. Additionally, it incorporates embedded APIs that enable L2 forwarding and L3 routing between various stations. The station build component works in conjunction with the topology build component to support test cases that involve packet transmission.

3. The lifecycle and dependency management component under the utils folder helps managing the lifecycle of C data structures, SAI objects/entries, and their dependencies. This functionality is capable of allocating and freeing memory for the C data structures in the backend, thereby ensuring that users and contributors do not need to be concerned about memory leaks. Additionally, it can automatically manage SAI objects/entries. Upon the completion of a test case, this service automatically cleans up all the SAI objects/entries in an order that respects their dependencies. Consequently, this enables contributors to focus solely on the implementation of test cases, thereby lowering the barriers to development.


A dedicated `cases` folder contains all test cases in SAI Validation. These tests are specifically crafted to assess the functionality of the SAI Validation framework. Pytest is utilized to identify and execute all test cases within this folder. The test cases are organized based on the APIs they are designed to evaluate. For instance, test cases in `test_fdb.py` focus on verifying the functionality of SAI APIs related to the Forwarding Database (FDB). Management of these test cases is handled by a test management module, which establishes the sequence in which the tests are run. This organization ensures that the tests are conducted according to the dependency chain among various SAI objects and entries. 

Test cases in SAI Validation calls the APIs generated by PySAI. Figure 4 illustrates a sequence of API calls within the SAI Validation docker. Initially, test cases in the SAI Validation framework invoke APIs in `sai_xxx.py`, which in turn call APIs from the `SaiObject` class located in `saiobject.py`. Subsequently, these calls are forwarded to APIs in `saiswig.py`. The APIs in `saiswig.py` then access the implementation in `_saiswig.so`, which ultimately interfaces with `libsai.so`.

<p align="center">
  <img src="API_chain.png" alt="Figure 4. Chain of API Calls" width="200">
  </p>
  <p align="center"><em>Figure 4. Chain of API Calls</em></p>


In SAI Validation, a manual or interactive mode is available that supports line-by-line execution of tests. This functionality can help diagnose failures and refine test cases. By enabling tests to be executed step-by-step, it provides immediate feedback and facilitates effective debugging. Additionally, this mode simplifies the process for external contributors, making it easier to develop and enhance the system.


### 6. Requirements

SAI Validation and PySAI operate independently from SONiC deployment, requiring only a specific set of components to function effectively. These components include:

- SWIG: A tool to bridge C APIs to Python APIs.
- libsai.so: This dynamic library must be installed within the SAI Validation Docker environment, typically via SAI Debian packages.
- generateDS: A tool used for generating data structures from XML schema, facilitating configuration and data management.
- pytest: A testing framework that allows for writing and running tests in Python, crucial for automated testing of the APIs.
- scapy: A Python library used for packet manipulation.
- Jinja2: A templating engine for Python, used to generate text files based on templates, which is vital for rendering the Python APIs in a more pythonic manner.


### 7. Open/Action items

As we continue to evolve and improve the SAI Validation framework, we invite the community to participate actively in our journey towards more robust, comprehensive, and reliable software. We believe that community contributions are vital to our projectâ€™s success and resilience.

Why Your Contributions Matter: Our goal is to ensure that the SAI Validation framework remains at the forefront of technology, capable of handling a diverse range of scenarios and configurations. By making contributions, you help enhance the accuracy and efficiency of the framework, aiding in the detection and resolution of issues before they impact users.

What Weâ€™re Looking For: We welcome contributions that:

- Expand the coverage of existing features and APIs.
- Introduce scenarios with new and diverse configurations.
- Address edge cases that may not currently be covered.
- Help verify bug fixes and new features to prevent regressions.